// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct FarmStakingProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for FarmStakingProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = FarmStakingProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        FarmStakingProxyMethods { wrapped_tx: tx }
    }
}

pub struct FarmStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> FarmStakingProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        farming_token_id: Arg0,
        division_safety_constant: Arg1,
        config_sc_address: Arg2,
        guild_master: Arg3,
        admins: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&farming_token_id)
            .argument(&division_safety_constant)
            .argument(&config_sc_address)
            .argument(&guild_master)
            .argument(&admins)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> FarmStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> FarmStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn merge_farm_tokens_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mergeFarmTokens")
            .original_result()
    }

    pub fn check_local_roles_set(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("checkLocalRolesSet")
            .original_result()
    }

    pub fn calculate_rewards_for_given_position<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<StakingFarmTokenAttributes<Env::Api>>,
    >(
        self,
        user: Arg0,
        farm_token_amount: Arg1,
        attributes: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateRewardsForGivenPosition")
            .argument(&user)
            .argument(&farm_token_amount)
            .argument(&attributes)
            .original_result()
    }

    pub fn top_up_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("topUpRewards")
            .original_result()
    }

    pub fn start_produce_rewards_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("startProduceRewards")
            .original_result()
    }

    pub fn accumulated_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccumulatedRewards")
            .original_result()
    }

    pub fn reward_capacity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardCapacity")
            .original_result()
    }

    pub fn guild_master_rps(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGuildMasterRewardPerShare")
            .original_result()
    }

    pub fn user_rps(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserRewardPerShare")
            .original_result()
    }

    pub fn reward_reserve(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardReserve")
            .original_result()
    }

    pub fn farming_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFarmingTokenId")
            .original_result()
    }

    pub fn reward_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardTokenId")
            .original_result()
    }

    pub fn per_block_reward_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPerBlockRewardAmount")
            .original_result()
    }

    pub fn last_reward_block_nonce(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastRewardBlockNonce")
            .original_result()
    }

    pub fn division_safety_constant(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDivisionSafetyConstant")
            .original_result()
    }

    pub fn register_farm_token(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerFarmToken")
            .original_result()
    }

    pub fn set_transfer_role_farm_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTransferRoleFarmToken")
            .original_result()
    }

    pub fn farm_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFarmTokenId")
            .original_result()
    }

    pub fn farm_token_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFarmTokenSupply")
            .original_result()
    }

    pub fn add_to_pause_whitelist<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        address_list: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addToPauseWhitelist")
            .argument(&address_list)
            .original_result()
    }

    pub fn remove_from_pause_whitelist<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        address_list: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeFromPauseWhitelist")
            .argument(&address_list)
            .original_result()
    }

    pub fn pause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    pub fn resume(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("resume")
            .original_result()
    }

    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, pausable::State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    pub fn add_admin_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn remove_admin_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmin")
            .argument(&address)
            .original_result()
    }

    pub fn update_owner_or_admin_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        previous_owner: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateOwnerOrAdmin")
            .argument(&previous_owner)
            .original_result()
    }

    pub fn permissions<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPermissions")
            .argument(&address)
            .original_result()
    }

    pub fn stake_farm_endpoint<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_original_caller: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("stakeFarm")
            .argument(&opt_original_caller)
            .original_result()
    }

    pub fn claim_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("claimRewards")
            .original_result()
    }

    pub fn compound_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("compoundRewards")
            .original_result()
    }

    pub fn unstake_farm(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("unstakeFarm")
            .original_result()
    }

    pub fn unbond_farm(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("unbondFarm")
            .original_result()
    }

    pub fn cancel_unbond(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("cancelUnbond")
            .original_result()
    }

    pub fn register_unbond_token(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerUnbondToken")
            .original_result()
    }

    pub fn set_transfer_role_unbond_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTransferRoleUnbondToken")
            .original_result()
    }

    pub fn unbond_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUnbondTokenId")
            .original_result()
    }

    pub fn get_user_staked_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserStakedTokens")
            .argument(&user)
            .original_result()
    }

    pub fn close_guild(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("closeGuild")
            .original_result()
    }

    pub fn migrate_to_other_guild<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        guild_address: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("migrateToOtherGuild")
            .argument(&guild_address)
            .original_result()
    }

    pub fn guild_closing(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isGuildClosing")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct StakingFarmTokenAttributes<Api>
where
    Api: ManagedTypeApi,
{
    pub reward_per_share: BigUint<Api>,
    pub compounded_reward: BigUint<Api>,
    pub current_farm_amount: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct EnterFarmEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub farming_token_id: TokenIdentifier<Api>,
    pub farming_token_amount: BigUint<Api>,
    pub farm_token: EsdtTokenPayment<Api>,
    pub farm_supply: BigUint<Api>,
    pub reward_token_id: TokenIdentifier<Api>,
    pub reward_token_reserve: BigUint<Api>,
    pub farm_attributes: ManagedBuffer<Api>,
    pub created_with_merge: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct ExitFarmEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub farming_token_id: TokenIdentifier<Api>,
    pub farming_token_amount: BigUint<Api>,
    pub farm_supply: BigUint<Api>,
    pub reward_tokens: EsdtTokenPayment<Api>,
    pub reward_reserve: BigUint<Api>,
    pub farm_attributes: ManagedBuffer<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct ClaimRewardsEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub old_farm_token: EsdtTokenPayment<Api>,
    pub new_farm_token: EsdtTokenPayment<Api>,
    pub farm_supply: BigUint<Api>,
    pub reward_tokens: EsdtTokenPayment<Api>,
    pub reward_reserve: BigUint<Api>,
    pub old_farm_attributes: ManagedBuffer<Api>,
    pub new_farm_attributes: ManagedBuffer<Api>,
    pub created_with_merge: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct CompoundRewardsEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub old_farm_token: EsdtTokenPayment<Api>,
    pub new_farm_token: EsdtTokenPayment<Api>,
    pub farm_supply: BigUint<Api>,
    pub reward_tokens: EsdtTokenPayment<Api>,
    pub reward_reserve: BigUint<Api>,
    pub old_farm_attributes: ManagedBuffer<Api>,
    pub new_farm_attributes: ManagedBuffer<Api>,
    pub created_with_merge: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct CancelUnbondEventData<Api>
where
    Api: ManagedTypeApi,
{
    pub unbond_attributes: UnbondSftAttributes<Api>,
    pub new_farm_token: EsdtTokenPayment<Api>,
    pub attributes: StakingFarmTokenAttributes<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct UnbondSftAttributes<Api>
where
    Api: ManagedTypeApi,
{
    pub unlock_epoch: u64,
    pub supply: BigUint<Api>,
    pub opt_original_attributes: Option<StakingFarmTokenAttributes<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct MigrateToOtherFarmData<Api>
where
    Api: ManagedTypeApi,
{
    pub guild_address: ManagedAddress<Api>,
    pub total_farming_tokens: BigUint<Api>,
    pub base_rewards: EsdtTokenPayment<Api>,
}
