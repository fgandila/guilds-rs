// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct GuildScConfigProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for GuildScConfigProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = GuildScConfigProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        GuildScConfigProxyMethods { wrapped_tx: tx }
    }
}

pub struct GuildScConfigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> GuildScConfigProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<InitArgs<Env::Api>>,
    >(
        self,
        args: Arg0,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&args)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> GuildScConfigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> GuildScConfigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn set_max_staked_tokens<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        max_staked_tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxStakedTokens")
            .argument(&max_staked_tokens)
            .original_result()
    }

    /// Pairs of (max_stake, apr) 
    /// APR is scaled by two decimals, i.e. 10_000 is 100% 
    /// Last max_stake value must be equal to the init value of max_staked_tokens 
    pub fn add_guild_master_tiers<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, u64>>>,
    >(
        self,
        tiers: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addGuildMasterTiers")
            .argument(&tiers)
            .original_result()
    }

    /// Pairs of (max_stake, apr) 
    /// APR is scaled by two decimals, i.e. 10_000 is 100% 
    /// Last max_stake value must be equal to the init value of max_staked_tokens 
    pub fn update_guild_master_tiers<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, u64>>>,
    >(
        self,
        tiers: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateGuildMasterTiers")
            .argument(&tiers)
            .original_result()
    }

    pub fn set_guild_master_tier_apr<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        max_stake: Arg0,
        new_apr: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setGuildMasterTierApr")
            .argument(&max_stake)
            .argument(&new_apr)
            .original_result()
    }

    /// Pairs of (max_percentage_staked, apr) 
    /// Both percentages are scaled by two decimals, i.e. 10_000 is 100% 
    /// max_percentage_staked must be <= 10_000, and the last one must be 10_000 
    pub fn add_user_tiers<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<u64, u64>>>,
    >(
        self,
        tiers: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addUserTiers")
            .argument(&tiers)
            .original_result()
    }

    /// Pairs of (max_percentage_staked, apr) 
    /// Both percentages are scaled by two decimals, i.e. 10_000 is 100% 
    /// max_percentage_staked must be <= 10_000, and the last one must be 10_000 
    pub fn update_user_tiers<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<u64, u64>>>,
    >(
        self,
        tiers: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateUserTiers")
            .argument(&tiers)
            .original_result()
    }

    pub fn set_user_tier_apr<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        max_percentage_staked: Arg0,
        new_apr: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUserTierApr")
            .argument(&max_percentage_staked)
            .argument(&new_apr)
            .original_result()
    }

    pub fn guild_master_tiers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, GuildMasterRewardTier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGuildMasterTiers")
            .original_result()
    }

    pub fn user_tiers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, UserRewardTier>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserTiers")
            .original_result()
    }

    pub fn set_min_stake_user<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        min_stake: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinStakeUser")
            .argument(&min_stake)
            .original_result()
    }

    pub fn set_min_stake_guild_master<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        min_stake: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinStakeGuildMaster")
            .argument(&min_stake)
            .original_result()
    }

    pub fn set_total_staking_token_minted<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        total_minted: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTotalStakingTokenMinted")
            .argument(&total_minted)
            .original_result()
    }

    pub fn increase_staked_tokens<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("increaseStakedTokens")
            .argument(&amount)
            .original_result()
    }

    pub fn decrease_staked_tokens<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("decreaseStakedTokens")
            .argument(&amount)
            .original_result()
    }

    pub fn set_seconds_per_block<
        Arg0: ProxyArg<u64>,
    >(
        self,
        new_seconds_per_block: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSecondsPerBlock")
            .argument(&new_seconds_per_block)
            .original_result()
    }

    pub fn set_per_block_reward_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_per_block_reward_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPerBlockRewardAmount")
            .argument(&new_per_block_reward_amount)
            .original_result()
    }

    pub fn pause_all_guilds(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseAllGuilds")
            .original_result()
    }

    pub fn unpause_all_guilds(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpauseAllGuilds")
            .original_result()
    }

    pub fn max_staked_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxStakedTokens")
            .original_result()
    }

    pub fn min_unbond_epochs_user(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinUnbondEpochsUser")
            .original_result()
    }

    pub fn min_unbond_epochs_guild_master(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinUnbondEpochsGuildMaster")
            .original_result()
    }

    pub fn min_stake_user(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinStakeUser")
            .original_result()
    }

    pub fn min_stake_guild_master(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinStakeGuildMaster")
            .original_result()
    }

    pub fn total_staking_token_minted(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStakingTokenMinted")
            .original_result()
    }

    pub fn total_staking_token_staked(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStakingTokenStaked")
            .original_result()
    }

    pub fn base_farm_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseFarmTokenId")
            .original_result()
    }

    pub fn base_unbond_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseUnbondTokenId")
            .original_result()
    }

    pub fn base_token_display_name(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseTokenDisplayName")
            .original_result()
    }

    pub fn tokens_decimals(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenDecimals")
            .original_result()
    }

    pub fn seconds_per_block(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSecondsPerBlock")
            .original_result()
    }

    pub fn per_block_reward_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPerBlockRewardAmount")
            .original_result()
    }

    pub fn global_pause_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("areAllGuildsPaused")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct InitArgs<Api>
where
    Api: ManagedTypeApi,
{
    pub total_staking_tokens_minted: BigUint<Api>,
    pub max_staked_tokens: BigUint<Api>,
    pub user_unbond_epochs: u64,
    pub guild_master_unbond_epochs: u64,
    pub min_stake_user: BigUint<Api>,
    pub min_stake_guild_master: BigUint<Api>,
    pub base_farm_token_id: ManagedBuffer<Api>,
    pub base_unbond_token_id: ManagedBuffer<Api>,
    pub base_token_display_name: ManagedBuffer<Api>,
    pub tokens_decimals: usize,
    pub seconds_per_block: u64,
    pub per_block_reward_amount: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct GuildMasterRewardTier<Api>
where
    Api: ManagedTypeApi,
{
    pub max_stake: BigUint<Api>,
    pub apr: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct UserRewardTier {
    pub max_percentage_staked: u64,
    pub apr: u64,
}
